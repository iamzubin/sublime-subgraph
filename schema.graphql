enum Status {
  VERIFIED
  UNVERIFIED
}

enum LoanStatus {
  Collecting
  Active
  Closed
  Cancelled
  Defaulted
  Terminated
}

type GlobalPoolDetail @entity{
  id:ID!
  admin: String!
  collectionPeriod:BigInt
  matchCollateralRatioInterval:BigInt
  marginCallDuration:BigInt
  collateralVolatilityThreshold:BigInt
  gracePeriodPenaltyFraction:BigInt
  liquidatorRewardFraction:BigInt
  votingPassRatio:BigInt
  gracePeriodFraction:BigInt

}

type LendingDetails @entity {
  id: ID!
  pool: Pool
  lender: User
  # amountSupplied: BigInt
  amountWithdrawn: BigInt
  repaymentWithdrawn: BigInt
  collateralCalled: Boolean
  lastVoteTime:BigInt
  marginCallEndTime:BigInt
  exraLiquidityShares:BigInt
  Balance:BigInt
}




type LendingDetailscopy @entity {
  id: ID!
  pool: Pool
  lender: User
  # amountSupplied: BigInt
  # amountWithdrawn: BigInt
  # repaymentWithdrawn: BigInt
  # collateralCalled: Boolean
  # lastVoteTime:BigInt
  # marginCallEndTime:BigInt
  # exraLiquidityShares:BigInt
  AmountLend:BigInt
}

type Pool @entity {
  id: ID!
  borrower: User
  borrowAsset: Bytes
  borrowAmountRequested:BigInt
  minborrowAmount:BigInt
  matchCollateralRatioEndTime:BigInt
  noOfRepaymentIntervals:BigInt
  investedTo:Bytes
  collateralAsset: Bytes
  lendingRate: BigInt
  borrowRate: BigInt
  loanDuration: BigInt
  idealCollateralRatio: BigInt
  loanStatus: LoanStatus
  repaymentInterval:BigInt
  poolSavingsStrategy:Bytes
  # collateralShare:BigInt
  # lentAmount: BigInt
  # borrowedAmount: BigInt
  # collateralAmount: BigInt
  loanWithdrawalDeadline:BigInt
  amountRepaid: BigInt
  loanStartTime: BigInt
  nextRepayTime: BigInt
  # collateralCalls: BigInt
  # whitelistedAddress: [Bytes]
  # voteWeight: BigInt
  baseLiquidityShares:BigInt
  extraLiquidityShares:BigInt
  noOfGracePeriodsTaken:BigInt
  nextDuePeriod:BigInt
  repayExtensionEndTime: BigInt
  lenders: [LendingDetailscopy!] @derivedFrom(field: "pool")
  liquidatedLenders: [poolLiquidation!] @derivedFrom(field: "pool")
  poolLiquidated: poolLiquidation 
  published: BigInt
  lentAmount:BigInt
  tokenImpl: String
  nextDueTime: BigInt
}

type poolLiquidation @entity{
  id:ID!
  pool: Pool
  lender: Bytes
  liquidator:Bytes
  liquidatedAmount: BigInt
  timeStamp:BigInt
  suppliedAmount: BigInt
}

type User @entity {
  id: ID!
  borrowingPools: [Pool!] @derivedFrom(field: "borrower")
  lendingPools: [LendingDetailscopy!] @derivedFrom(field: "lender")
  status: Status!
  twitterDetails: TwitterDetail
}
  
type TwitterDetail @entity {
  id: ID!
  twitterId: Bytes!
  twitterSignMessage: String
  registrationTime: BigInt  
  linkedAddresses: [Bytes!]
}

type SavingAccount @entity {
  id: ID!
  user: User
  deposits: [SavingsDeposit!] @derivedFrom(field: "savingAccount")
  allowances: [SavingsDeposit!] @derivedFrom(field: "savingAccount")
}

type SavingsDeposit @entity {
  id: ID!
  asset: Bytes
  amount: BigInt
  strategy: Bytes
  savingAccount: SavingAccount
  liquidityShare: BigInt
}


enum CreditLineStatus {
  NOT_CREATED
  REQUESTED
  ACTIVE
  CLOSED
  CANCELLED
  LIQUIDATED
}

type CreditLineCollateralInfo @entity {
  id: ID!
  amount: BigInt
  strategy: Bytes
  creditLines: CreditLine
}

# Used to keep track of a user's pofile (list of wallet addresses 
# and identity integrations like Twitter, etc.) 
type UserProfile @entity {
  # id will be the user's primary wallet address
  id: ID!
  walletAddresses: [WalletAddress!]! @derivedFrom(field: "owner")
  identityIntegrations: [Identity!]! @derivedFrom(field: "owner")
  verified: Boolean!
  displayName: String!
}

# Used to store a identity integration (Twitter, etc.)
type Identity @entity {
  id: ID!
  # which verification method was used for the mapping
  verificationMethod: String!
  # identity can sometimes have a userName for frontend display and an 
  # underlying unique ID (like Twitter). Value can be string (username) or int (userID) converted to string
  userName: String!
  userID: String!
  owner: UserProfile!
}

# Maps wallet address to UserProfile (owner of the wallet address)
# Assumption: wallets have a single owner
type WalletAddress @entity {
  #wallet address
  id: ID!
  owner: UserProfile!
}

type CreditLine @entity {
  #creditLine hash
  id: ID!
  # stores who requested the credit line
  requestedBy: UserProfile!
  # status
  status: CreditLineStatus!
  # borrower user profile
  borrower: UserProfile!
  # borrower address
  borrowerAddress: Bytes!
  # lender user profile
  lender: UserProfile!
  # lender address
  lenderAddress: Bytes!
  # credit limit
  borrowLimit: BigInt!
  # liquidation threshold
  liquidationThreshold: BigInt!
  # interest Rate
  borrowRate: BigInt!
  # ideal collateral ratio
  idealCollateralRatio: BigInt!
  # borrow Asset
  borrowAsset: Bytes!
  # collateral asset
  collateralAsset: Bytes!
  # auto-liquidation
  autoLiquidate: Boolean!
  # active principal borrowed
  activePrincipal: BigInt!
  # active collateral deposited
  activeCollateral: BigInt!
  # total interest repaid
  totalInterestRepaid: BigInt!
  # interest accrued since the last time principal was updated
  interestAccruedTillPrincipalUpdate: BigInt!
  # time when the principal was last updated (either through repayment or borrowing)
  lastPrincipalUpdateTime: BigInt!
  # array of all liquidations associated with given credit line 
  #(assumption: credit line stays active even after liquidation)
  liquidationHistory: CreditLineLiquidationEvent @derivedFrom(field: "creditLine")
  borrowingHistory: [CreditLineBorrowingEvent!]! @derivedFrom(field: "creditLine")
  repaymentHistory: [CreditLineRepaymentEvent!]! @derivedFrom(field: "creditLine")
  oracleAddress: Bytes!
  protocolFee: BigInt!
}

type CreditLineLiquidationEvent @entity {
  id: ID!
  liquidator: Bytes!
  creditLine: CreditLine!
  amountLiquidatedInCollateralAsset: BigInt!
}

type CreditLineBorrowingEvent @entity {
  id: ID!
  borrowAmount: BigInt!
  creditLine: CreditLine!
}

type CreditLineRepaymentEvent @entity {
  id: ID!
  creditLine: CreditLine!
  repayAmount: BigInt!
}



#type creditLineLiquidation @entity{
#  id:ID!
#  creditLine: CreditLine
#  Borrower: Bytes
#  liquidator:Bytes
#  liquidatedAmount: BigInt
#  suppliedAmount: BigInt
#  timeStamp:BigInt
#}

