type CreditLine @entity {
  #creditLine number
  id: ID!
  # credit line time line
  creditLineTimeline: [CreditLineTimeline!]! @derivedFrom(field: "creditLine")

  # Credit Line Constants
  lender: String
  borrower: String
  borrowLimit: BigInt
  idealCollateralRatio: BigInt
  borrowRate: BigInt
  borrowAsset: String
  collateralAsset: String
  autoLiquidation: Boolean
  requestByLender: Boolean

  # credit line variables
  status: CreditLineStatus
  principal: BigInt
  totalInterestRepaid: BigInt
  lastPrincipalUpdateTime: BigInt
  interestAccruedTillLastPrincipalUpdate: BigInt
}

type CreditLineGlobalParam @entity {
  # use always 1, to store the global params
  id: ID!
  # strategy registry
  strategyRegistry: String
  # savings account
  savingsAccount: String
  # protocol fee fraction
  protocolFeeFraction: BigInt
  # protocol fee collector
  protocolFeeCollector: String
  # price oracle
  priceOracle: String
  # liquidation reward fraction
  liquidationRewardFraction: BigInt
  # default strategy
  defaultStrategy: String
}

type CreditLineTimeline @entity {
  id: ID!
  creditLine: CreditLine!
  timestamp: BigInt
  creditLineOperation: CreditLineOperations
  amount: BigInt
  strategy: String
  liquidator: String
}

enum CreditLineStatus {
  NOT_CREATED
  REQUESTED
  ACTIVE
  CLOSED
  CANCELLED
  LIQUIDATED
}

enum CreditLineOperations {
  NOT_CREATED
  REQUESTED
  ACTIVE
  DEPOSIT_COLLATERAL
  BORROW
  REPAY
  WITHDRAW_COLLATERAL
  CLOSED
  CANCELLED
  RESET
  LIQUIDATED
}

type StrategyRegistry @entity {
  id: ID!
  max: BigInt!
  strategyOrder: [Strategy!]
}

type Strategy @entity {
  id: ID!
  address: String!
  enabled: Boolean!
}

type UserBalance @entity {
  id: ID!
  strategyBalance: [Balance!]!
  user: String!
  token: String!
}

type Balance @entity {
  id: ID!
  user: String!
  strategy: Strategy!
  token: String!
  shares: BigInt!
}

type Allowance @entity {
  id: ID!
  from: String!
  to: String!
  token: String!
  amount: BigInt!
}
